

## **为什么需要分布式锁**

在并发场景下，需要使用锁对共享资源互斥访问来保证线程安全；同样，在分布式场景下，也需要一种机制来保证对多节点共享资源的互斥访问，实现机制就是分布式锁。

## **分布式锁特性**

一般来说，分布式锁需要满足以下特性：

1. **（必备）互斥，**即保证不同节点不同线程的互斥访问。
2. **（必备）超时机制**，即超时设置，防止死锁。比如能够支持设置超时时间，防止其他节点一直无法获取到锁；同时需要防止获取锁的任务执行超时导致任务还没结束，锁超时自动释放而无法保证互斥性。
3. **（必备）提供阻塞和非阻塞接口**，例如lock和tryLock。
4. **（可选）可重入性**，同一节点同一条线程如果获取到锁可以再次获取锁。
5. （**可选）公平锁和非公平锁。**

其他要求

1. 高可用
2. 高性能

## 数据库实现

### 第一版本

在数据库中创建一张表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

```sql
create table `lock_table` (
    `id` int(11) unsigned NOT NULL auto_increment comment '主键',
    `resource_id` varchar(128) NOT NULL comment '标识资源,可能是某个方法',
    `desc` varchar(128) default NULL comment '描述',
    `ctime` bigint(20) NOT NULL COMMENT '创建时间',
    `utime` bigint(20) NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    UNIQUE KEY `unq_resource` (`resource_id`)
) engine=InnoDB default charset=utf8mb4
```

tryLock实现

```sql
insert into lock_table (resource_id, desc) values ('resource_name1', 'desc1')
```

unlock实现

```sql
delete from lock_table where resource_id = 'resource_name1'
```

以上是分布式锁一个简单的实现，它能满足互斥要求，但很明显存在一些问题：

1. 不具备可重入性。
2. 没有锁失效机制，可能导致死锁，如果设置超时，设置成多少合适。
3. 不具备阻塞等待特性；

如果对锁的可重入性、超时时间以及阻塞获取没有这三个需求，还是可以拿来用一用的。

### **改进方案**

- 阻塞获取锁

不获取到锁誓不罢休，一般写一个死循环来执行其操作

```java
@Override
public void lock() {
    while (!lockResource(this.resource)) {
        LockSupport.parkNanos(WAIT_TIME);
    }
}

private boolean lockResource(String resource) {
    // implement lock
    // insert int lock_table (resource_id) values ('ressource');
    return false;
}
```

- 可重入实现

主要是判断表内的clientId 和 当前的client 是否一样，一样就直接返回，并增加重入的次数

```java
@Transcation
private boolean lockResource(String resource) {
    if (lockTable.countByResource(resource) == 0) {
        return lockTable.insert(resource);
    }

    if (Objects.equals(lockTable.getClientId(resource), this.clientId)) {
        return lockTable.increment(resource);
    }

    return false;
}
```

完整实现如下。

```java
public class MySqlDistributedLock implements Lock {
    private static final long WAIT_TIME = 1000 * 1000 * 3;
    private LockTable lockTable;
    /**
     * 标识待锁定资源
     */
    private String resource;

    /**
     * 用于标识客户端，可以是ip+线程id等方式，用于实现可重入特性
     */
    private String clientId;

    public MySqlDistributedLock(LockTable lockTable, String resource) {
        this.lockTable = lockTable;
        this.resource = resource;
    }

    @Override
    @Transcation
    public void lock() {
        while (!lockResource(this.resource))
            LockSupport.parkNanos(WAIT_TIME);
    }

    @Override
    @Transcation
    public boolean tryLock() {
        return lockResource(this.resource);
    }

    @Override
    public boolean tryLock(long expires) {
        long endTime = System.currentTimeMillis() + expires;
        while (!lockResource(this.resource)) {
            if (System.currentTimeMillis() > endTime) {
                return false;
            }
        }
        return true;
    }

    @Override
    @Transcation
    public boolean unLock() {

        int count = lockTable.countForUpdate(this.resource);
        if (count == 0) return false;
        
        if (Objects.equals(lockTable.getClientId(resource), this.clientId)) {
            if (count > 1) return lockTable.decrement(this.resource);
            else return lockTable.delete(this.resource);
        }
        return false;
    }

    private boolean lockResource(String resource) {
        if (lockTable.countForUpdate(resource) == 0) {
            return lockTable.insert(resource);
        }

        if (Objects.equals(lockTable.getClientId(resource), this.clientId)) {
            return lockTable.increment(resource);
        }

        return false;
    }
}
```

此外，还需要一个后台定时任务不断扫描超时的任务。

### 小结

优点：比较简单，也不需要引入额外的中间件例如Redis或ZooKeeper

缺点：实现较为繁琐，需要自己考虑锁超时，可重入等各种情况；性能受局限于数据库性能



## zookeeper实现

## redis 实现

